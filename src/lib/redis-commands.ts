// Redis commands reference for autocomplete
export interface RedisCommand {
  name: string;
  args: string;
  summary: string;
  complexity: string;
}

export const REDIS_COMMANDS: RedisCommand[] = [
  { name: "APPEND", args: "key value", summary: "Append a value to a key", complexity: "O(1)" },
  { name: "AUTH", args: "password", summary: "Authenticate to the server", complexity: "O(1)" },
  {
    name: "BGREWRITEAOF",
    args: "",
    summary: "Asynchronously rewrite the append-only file",
    complexity: "O(1)",
  },
  {
    name: "BGSAVE",
    args: "",
    summary: "Asynchronously save the dataset to disk",
    complexity: "O(1)",
  },
  {
    name: "BITCOUNT",
    args: "key [start end]",
    summary: "Count set bits in a string",
    complexity: "O(N)",
  },
  {
    name: "BITFIELD",
    args: "key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]",
    summary: "Perform arbitrary bitfield integer operations on strings",
    complexity: "O(1)",
  },
  {
    name: "BITOP",
    args: "operation destkey key [key ...]",
    summary: "Perform bitwise operations between strings",
    complexity: "O(N)",
  },
  {
    name: "BITPOS",
    args: "key bit [start] [end]",
    summary: "Find first bit set or clear in a string",
    complexity: "O(N)",
  },
  {
    name: "BLPOP",
    args: "key [key ...] timeout",
    summary: "Remove and get the first element in a list, or block until one is available",
    complexity: "O(1)",
  },
  {
    name: "BRPOP",
    args: "key [key ...] timeout",
    summary: "Remove and get the last element in a list, or block until one is available",
    complexity: "O(1)",
  },
  {
    name: "BRPOPLPUSH",
    args: "source destination timeout",
    summary:
      "Pop a value from a list, push it to another list and return it; or block until one is available",
    complexity: "O(1)",
  },
  {
    name: "CLIENT",
    args: "subcommand [argument [argument ...]]",
    summary: "Client connection subcommands",
    complexity: "O(1)",
  },
  {
    name: "CLUSTER",
    args: "subcommand [argument [argument ...]]",
    summary: "Cluster management subcommands",
    complexity: "O(1)",
  },
  { name: "COMMAND", args: "", summary: "Get array of Redis command details", complexity: "O(N)" },
  {
    name: "CONFIG",
    args: "subcommand [argument [argument ...]]",
    summary: "Configuration subcommands",
    complexity: "O(1)",
  },
  {
    name: "DBSIZE",
    args: "",
    summary: "Return the number of keys in the selected database",
    complexity: "O(1)",
  },
  {
    name: "DEBUG",
    args: "subcommand [argument [argument ...]]",
    summary: "Debugging subcommands",
    complexity: "O(1)",
  },
  {
    name: "DECR",
    args: "key",
    summary: "Decrement the integer value of a key by one",
    complexity: "O(1)",
  },
  {
    name: "DECRBY",
    args: "key decrement",
    summary: "Decrement the integer value of a key by the given number",
    complexity: "O(1)",
  },
  { name: "DEL", args: "key [key ...]", summary: "Delete a key", complexity: "O(N)" },
  {
    name: "DISCARD",
    args: "",
    summary: "Discard all commands issued after MULTI",
    complexity: "O(1)",
  },
  {
    name: "DUMP",
    args: "key",
    summary: "Return a serialized version of the value stored at the specified key",
    complexity: "O(1)",
  },
  { name: "ECHO", args: "message", summary: "Echo the given string", complexity: "O(1)" },
  {
    name: "EVAL",
    args: "script numkeys key [key ...] arg [arg ...]",
    summary: "Execute a Lua script server side",
    complexity: "O(N)",
  },
  {
    name: "EVALSHA",
    args: "sha1 numkeys key [key ...] arg [arg ...]",
    summary: "Execute a Lua script server side by SHA1",
    complexity: "O(N)",
  },
  {
    name: "EXEC",
    args: "",
    summary: "Execute all commands issued after MULTI",
    complexity: "O(N)",
  },
  {
    name: "EXISTS",
    args: "key [key ...]",
    summary: "Determine if a key exists",
    complexity: "O(N)",
  },
  {
    name: "EXPIRE",
    args: "key seconds",
    summary: "Set a key's time to live in seconds",
    complexity: "O(1)",
  },
  {
    name: "EXPIREAT",
    args: "key timestamp",
    summary: "Set the expiration for a key as a UNIX timestamp",
    complexity: "O(1)",
  },
  {
    name: "FLUSHALL",
    args: "[ASYNC]",
    summary: "Remove all keys from all databases",
    complexity: "O(N)",
  },
  {
    name: "FLUSHDB",
    args: "[ASYNC]",
    summary: "Remove all keys from the current database",
    complexity: "O(N)",
  },
  {
    name: "GEOADD",
    args: "key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]",
    summary: "Add one or more geospatial items to a geospatial index",
    complexity: "O(log(N))",
  },
  {
    name: "GEODIST",
    args: "key member1 member2 [M|KM|FT|MI]",
    summary: "Returns the distance between two members of a geospatial index",
    complexity: "O(log(N))",
  },
  {
    name: "GEOHASH",
    args: "key member [member ...]",
    summary: "Returns members of a geospatial index as standard geohash strings",
    complexity: "O(log(N))",
  },
  {
    name: "GEOPOS",
    args: "key member [member ...]",
    summary: "Returns longitude and latitude of members of a geospatial index",
    complexity: "O(log(N))",
  },
  {
    name: "GEORADIUS",
    args: "key longitude latitude radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]",
    summary: "Query a geospatial index for members within a distance from a coordinate",
    complexity: "O(N+log(M))",
  },
  {
    name: "GEORADIUSBYMEMBER",
    args: "key member radius M|KM|FT|MI [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]",
    summary: "Query a geospatial index for members within a distance from a member",
    complexity: "O(N+log(M))",
  },
  { name: "GET", args: "key", summary: "Get the value of a key", complexity: "O(1)" },
  {
    name: "GETBIT",
    args: "key offset",
    summary: "Returns the bit value at offset in the string value stored at key",
    complexity: "O(1)",
  },
  {
    name: "GETRANGE",
    args: "key start end",
    summary: "Get a substring of the string stored at a key",
    complexity: "O(N)",
  },
  {
    name: "GETSET",
    args: "key value",
    summary: "Set the string value of a key and return its old value",
    complexity: "O(1)",
  },
  {
    name: "HDEL",
    args: "key field [field ...]",
    summary: "Delete one or more hash fields",
    complexity: "O(N)",
  },
  {
    name: "HEXISTS",
    args: "key field",
    summary: "Determine if a hash field exists",
    complexity: "O(1)",
  },
  { name: "HGET", args: "key field", summary: "Get the value of a hash field", complexity: "O(1)" },
  {
    name: "HGETALL",
    args: "key",
    summary: "Get all the fields and values in a hash",
    complexity: "O(N)",
  },
  {
    name: "HINCRBY",
    args: "key field increment",
    summary: "Increment the integer value of a hash field by the given number",
    complexity: "O(1)",
  },
  {
    name: "HINCRBYFLOAT",
    args: "key field increment",
    summary: "Increment the float value of a hash field by the given amount",
    complexity: "O(1)",
  },
  { name: "HKEYS", args: "key", summary: "Get all the fields in a hash", complexity: "O(N)" },
  { name: "HLEN", args: "key", summary: "Get the number of fields in a hash", complexity: "O(1)" },
  {
    name: "HMGET",
    args: "key field [field ...]",
    summary: "Get the values of all the given hash fields",
    complexity: "O(N)",
  },
  {
    name: "HMSET",
    args: "key field value [field value ...]",
    summary: "Set multiple hash fields to multiple values",
    complexity: "O(N)",
  },
  {
    name: "HSCAN",
    args: "key cursor [MATCH pattern] [COUNT count]",
    summary: "Incrementally iterate hash fields and associated values",
    complexity: "O(1)",
  },
  {
    name: "HSET",
    args: "key field value [field value ...]",
    summary: "Set the string value of a hash field",
    complexity: "O(1)",
  },
  {
    name: "HSETNX",
    args: "key field value",
    summary: "Set the value of a hash field, only if the field does not exist",
    complexity: "O(1)",
  },
  {
    name: "HSTRLEN",
    args: "key field",
    summary: "Get the length of the value of a hash field",
    complexity: "O(1)",
  },
  { name: "HVALS", args: "key", summary: "Get all the values in a hash", complexity: "O(N)" },
  {
    name: "INCR",
    args: "key",
    summary: "Increment the integer value of a key by one",
    complexity: "O(1)",
  },
  {
    name: "INCRBY",
    args: "key increment",
    summary: "Increment the integer value of a key by the given amount",
    complexity: "O(1)",
  },
  {
    name: "INCRBYFLOAT",
    args: "key increment",
    summary: "Increment the float value of a key by the given amount",
    complexity: "O(1)",
  },
  {
    name: "INFO",
    args: "[section]",
    summary: "Get information and statistics about the server",
    complexity: "O(1)",
  },
  {
    name: "KEYS",
    args: "pattern",
    summary: "Find all keys matching the given pattern",
    complexity: "O(N)",
  },
  {
    name: "LASTSAVE",
    args: "",
    summary: "Get the UNIX time stamp of the last successful save to disk",
    complexity: "O(1)",
  },
  {
    name: "LINDEX",
    args: "key index",
    summary: "Get an element from a list by its index",
    complexity: "O(N)",
  },
  {
    name: "LINSERT",
    args: "key BEFORE|AFTER pivot value",
    summary: "Insert an element before or after another element in a list",
    complexity: "O(N)",
  },
  { name: "LLEN", args: "key", summary: "Get the length of a list", complexity: "O(1)" },
  {
    name: "LPOP",
    args: "key [count]",
    summary: "Remove and get the first elements in a list",
    complexity: "O(N)",
  },
  {
    name: "LPUSH",
    args: "key value [value ...]",
    summary: "Prepend one or multiple values to a list",
    complexity: "O(1)",
  },
  {
    name: "LPUSHX",
    args: "key value",
    summary: "Prepend a value to a list, only if the list exists",
    complexity: "O(1)",
  },
  {
    name: "LRANGE",
    args: "key start stop",
    summary: "Get a range of elements from a list",
    complexity: "O(S+N)",
  },
  {
    name: "LREM",
    args: "key count value",
    summary: "Remove elements from a list",
    complexity: "O(N)",
  },
  {
    name: "LSET",
    args: "key index value",
    summary: "Set the value of an element in a list by its index",
    complexity: "O(N)",
  },
  {
    name: "LTRIM",
    args: "key start stop",
    summary: "Trim a list to the specified range",
    complexity: "O(N)",
  },
  {
    name: "MGET",
    args: "key [key ...]",
    summary: "Get the values of all the given keys",
    complexity: "O(N)",
  },
  {
    name: "MIGRATE",
    args: 'host port key|"" destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]',
    summary: "Atomically transfer a key from a Redis instance to another one",
    complexity: "O(N)",
  },
  {
    name: "MONITOR",
    args: "",
    summary: "Listen for all requests received by the server in real time",
    complexity: "O(1)",
  },
  { name: "MOVE", args: "key db", summary: "Move a key to another database", complexity: "O(1)" },
  {
    name: "MSET",
    args: "key value [key value ...]",
    summary: "Set multiple keys to multiple values",
    complexity: "O(N)",
  },
  {
    name: "MSETNX",
    args: "key value [key value ...]",
    summary: "Set multiple keys to multiple values, only if none of the keys exist",
    complexity: "O(N)",
  },
  { name: "MULTI", args: "", summary: "Mark the start of a transaction block", complexity: "O(1)" },
  {
    name: "OBJECT",
    args: "subcommand [arguments [arguments ...]]",
    summary: "Inspect the internals of Redis objects",
    complexity: "O(1)",
  },
  { name: "PERSIST", args: "key", summary: "Remove the expiration from a key", complexity: "O(1)" },
  {
    name: "PEXPIRE",
    args: "key milliseconds",
    summary: "Set a key's time to live in milliseconds",
    complexity: "O(1)",
  },
  {
    name: "PEXPIREAT",
    args: "key milliseconds-timestamp",
    summary: "Set the expiration for a key as a UNIX timestamp specified in milliseconds",
    complexity: "O(1)",
  },
  {
    name: "PFADD",
    args: "key element [element ...]",
    summary: "Adds the specified elements to the specified HyperLogLog",
    complexity: "O(1)",
  },
  {
    name: "PFCOUNT",
    args: "key [key ...]",
    summary:
      "Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)",
    complexity: "O(N)",
  },
  {
    name: "PFMERGE",
    args: "destkey sourcekey [sourcekey ...]",
    summary: "Merge N different HyperLogLogs into a single one",
    complexity: "O(N)",
  },
  { name: "PING", args: "[message]", summary: "Ping the server", complexity: "O(1)" },
  {
    name: "PSETEX",
    args: "key milliseconds value",
    summary: "Set the value and expiration in milliseconds of a key",
    complexity: "O(1)",
  },
  {
    name: "PSUBSCRIBE",
    args: "pattern [pattern ...]",
    summary: "Listen for messages published to channels matching the given patterns",
    complexity: "O(N)",
  },
  {
    name: "PTTL",
    args: "key",
    summary: "Get the time to live for a key in milliseconds",
    complexity: "O(1)",
  },
  {
    name: "PUBLISH",
    args: "channel message",
    summary: "Post a message to a channel",
    complexity: "O(N+M)",
  },
  {
    name: "PUBSUB",
    args: "subcommand [argument [argument ...]]",
    summary: "Inspect the state of the Pub/Sub subsystem",
    complexity: "O(N)",
  },
  {
    name: "PUNSUBSCRIBE",
    args: "[pattern [pattern ...]]",
    summary: "Stop listening for messages posted to channels matching the given patterns",
    complexity: "O(N)",
  },
  { name: "QUIT", args: "", summary: "Close the connection", complexity: "O(1)" },
  {
    name: "RANDOMKEY",
    args: "",
    summary: "Return a random key from the keyspace",
    complexity: "O(1)",
  },
  {
    name: "READONLY",
    args: "",
    summary: "Enables read queries for a connection to a cluster replica node",
    complexity: "O(1)",
  },
  {
    name: "READWRITE",
    args: "",
    summary: "Disables read queries for a connection to a cluster replica node",
    complexity: "O(1)",
  },
  { name: "RENAME", args: "key newkey", summary: "Rename a key", complexity: "O(1)" },
  {
    name: "RENAMENX",
    args: "key newkey",
    summary: "Rename a key, only if the new key does not exist",
    complexity: "O(1)",
  },
  {
    name: "RESTORE",
    args: "key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]",
    summary: "Create a key using the provided serialized value, previously obtained using DUMP",
    complexity: "O(1)",
  },
  {
    name: "ROLE",
    args: "",
    summary: "Return the role of the instance in the context of replication",
    complexity: "O(1)",
  },
  {
    name: "RPOP",
    args: "key [count]",
    summary: "Remove and get the last elements in a list",
    complexity: "O(N)",
  },
  {
    name: "RPOPLPUSH",
    args: "source destination",
    summary: "Remove the last element in a list, prepend it to another list and return it",
    complexity: "O(1)",
  },
  {
    name: "RPUSH",
    args: "key value [value ...]",
    summary: "Append one or multiple values to a list",
    complexity: "O(1)",
  },
  {
    name: "RPUSHX",
    args: "key value",
    summary: "Append a value to a list, only if the list exists",
    complexity: "O(1)",
  },
  {
    name: "SADD",
    args: "key member [member ...]",
    summary: "Add one or more members to a set",
    complexity: "O(N)",
  },
  { name: "SAVE", args: "", summary: "Synchronously save the dataset to disk", complexity: "O(N)" },
  {
    name: "SCAN",
    args: "cursor [MATCH pattern] [COUNT count] [TYPE type]",
    summary: "Incrementally iterate the keys space",
    complexity: "O(1)",
  },
  { name: "SCARD", args: "key", summary: "Get the number of members in a set", complexity: "O(1)" },
  {
    name: "SCRIPT",
    args: "subcommand [arguments [arguments ...]]",
    summary: "Lua scripting management subcommands",
    complexity: "O(N)",
  },
  { name: "SDIFF", args: "key [key ...]", summary: "Subtract multiple sets", complexity: "O(N)" },
  {
    name: "SDIFFSTORE",
    args: "destination key [key ...]",
    summary: "Subtract multiple sets and store the resulting set in a key",
    complexity: "O(N)",
  },
  {
    name: "SELECT",
    args: "index",
    summary: "Change the selected database for the current connection",
    complexity: "O(1)",
  },
  {
    name: "SET",
    args: "key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]",
    summary: "Set the string value of a key",
    complexity: "O(1)",
  },
  {
    name: "SETBIT",
    args: "key offset value",
    summary: "Sets or clears the bit at offset in the string value stored at key",
    complexity: "O(1)",
  },
  {
    name: "SETEX",
    args: "key seconds value",
    summary: "Set the value and expiration of a key",
    complexity: "O(1)",
  },
  {
    name: "SETNX",
    args: "key value",
    summary: "Set the value of a key, only if the key does not exist",
    complexity: "O(1)",
  },
  {
    name: "SETRANGE",
    args: "key offset value",
    summary: "Overwrite part of a string at key starting at the specified offset",
    complexity: "O(1)",
  },
  {
    name: "SHUTDOWN",
    args: "[NOSAVE|SAVE] [NOW] [FORCE] [ABORT]",
    summary: "Synchronously save the dataset to disk and then shut down the server",
    complexity: "O(N)",
  },
  {
    name: "SINTER",
    args: "key [key ...]",
    summary: "Intersect multiple sets",
    complexity: "O(N*M)",
  },
  {
    name: "SINTERSTORE",
    args: "destination key [key ...]",
    summary: "Intersect multiple sets and store the resulting set in a key",
    complexity: "O(N*M)",
  },
  {
    name: "SISMEMBER",
    args: "key member",
    summary: "Determine if a given value is a member of a set",
    complexity: "O(1)",
  },
  {
    name: "SLAVEOF",
    args: "host port",
    summary: "Make the server a replica of another instance, or promote it as master",
    complexity: "O(1)",
  },
  {
    name: "SLOWLOG",
    args: "subcommand [argument]",
    summary: "Manages the Redis slow queries log",
    complexity: "O(1)",
  },
  { name: "SMEMBERS", args: "key", summary: "Get all the members in a set", complexity: "O(N)" },
  {
    name: "SMOVE",
    args: "source destination member",
    summary: "Move a member from one set to another",
    complexity: "O(1)",
  },
  {
    name: "SORT",
    args: "key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]",
    summary: "Sort the elements in a list, set or sorted set",
    complexity: "O(N+M*log(M))",
  },
  {
    name: "SPOP",
    args: "key [count]",
    summary: "Remove and return one or multiple random members from a set",
    complexity: "O(N)",
  },
  {
    name: "SRANDMEMBER",
    args: "key [count]",
    summary: "Get one or multiple random members from a set",
    complexity: "O(N)",
  },
  {
    name: "SREM",
    args: "key member [member ...]",
    summary: "Remove one or more members from a set",
    complexity: "O(N)",
  },
  {
    name: "SSCAN",
    args: "key cursor [MATCH pattern] [COUNT count]",
    summary: "Incrementally iterate Set elements",
    complexity: "O(1)",
  },
  {
    name: "STRLEN",
    args: "key",
    summary: "Get the length of the value stored in a key",
    complexity: "O(1)",
  },
  {
    name: "SUBSCRIBE",
    args: "channel [channel ...]",
    summary: "Listen for messages published to the given channels",
    complexity: "O(N)",
  },
  { name: "SUNION", args: "key [key ...]", summary: "Add multiple sets", complexity: "O(N)" },
  {
    name: "SUNIONSTORE",
    args: "destination key [key ...]",
    summary: "Add multiple sets and store the resulting set in a key",
    complexity: "O(N)",
  },
  {
    name: "SWAPDB",
    args: "index1 index2",
    summary: "Swaps two Redis databases",
    complexity: "O(1)",
  },
  { name: "SYNC", args: "", summary: "Internal command used for replication", complexity: "O(1)" },
  { name: "TIME", args: "", summary: "Return the current server time", complexity: "O(1)" },
  { name: "TTL", args: "key", summary: "Get the time to live for a key", complexity: "O(1)" },
  { name: "TYPE", args: "key", summary: "Determine the type stored at key", complexity: "O(1)" },
  {
    name: "UNSUBSCRIBE",
    args: "[channel [channel ...]]",
    summary: "Stop listening for messages posted to the given channels",
    complexity: "O(N)",
  },
  { name: "UNWATCH", args: "", summary: "Forget about all watched keys", complexity: "O(1)" },
  {
    name: "WAIT",
    args: "numreplicas timeout",
    summary:
      "Wait for the synchronous replication of all the write commands sent in the context of the current connection",
    complexity: "O(1)",
  },
  {
    name: "WATCH",
    args: "key [key ...]",
    summary: "Watch the given keys to determine execution of the MULTI/EXEC block",
    complexity: "O(1)",
  },
  {
    name: "XACK",
    args: "key group ID [ID ...]",
    summary:
      "Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group",
    complexity: "O(1)",
  },
  {
    name: "XADD",
    args: "key ID field value [field value ...]",
    summary: "Appends a new entry to a stream",
    complexity: "O(1)",
  },
  {
    name: "XCLAIM",
    args: "key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [FORCE] [JUSTID]",
    summary:
      "Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer",
    complexity: "O(log N)",
  },
  {
    name: "XDEL",
    args: "key ID [ID ...]",
    summary: "Removes the specified entries from the stream",
    complexity: "O(1)",
  },
  {
    name: "XGROUP",
    args: "subcommand key [groupname [consumername]]",
    summary: "Create, destroy, and manage consumer groups",
    complexity: "O(N)",
  },
  {
    name: "XINFO",
    args: "subcommand key [group|consumer]",
    summary: "Get information on streams and consumer groups",
    complexity: "O(N)",
  },
  {
    name: "XLEN",
    args: "key",
    summary: "Return the number of entires in a stream",
    complexity: "O(1)",
  },
  {
    name: "XPENDING",
    args: "key group [start end count] [consumer]",
    summary: "Return information and entries from a stream consumer group pending entries list",
    complexity: "O(N)",
  },
  {
    name: "XRANGE",
    args: "key start end [COUNT count]",
    summary: "Return a range of elements in a stream",
    complexity: "O(N)",
  },
  {
    name: "XREAD",
    args: "[COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]",
    summary:
      "Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream",
    complexity: "O(N)",
  },
  {
    name: "XREADGROUP",
    args: "group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]",
    summary: "Return new entries from a stream using a consumer group",
    complexity: "O(N)",
  },
  {
    name: "XREVRANGE",
    args: "key end start [COUNT count]",
    summary: "Return a range of elements in a stream, reversed",
    complexity: "O(N)",
  },
  {
    name: "XTRIM",
    args: "key MAXLEN [~] count",
    summary: "Trims the stream to a given number of items",
    complexity: "O(N)",
  },
  {
    name: "ZADD",
    args: "key [NX|XX] [CH] [INCR] score member [score member ...]",
    summary: "Add one or more members to a sorted set, or update its score if it already exists",
    complexity: "O(log(N))",
  },
  {
    name: "ZCARD",
    args: "key",
    summary: "Get the number of members in a sorted set",
    complexity: "O(1)",
  },
  {
    name: "ZCOUNT",
    args: "key min max",
    summary: "Count the members in a sorted set with scores within the given values",
    complexity: "O(log(N))",
  },
  {
    name: "ZINCRBY",
    args: "key increment member",
    summary: "Increment the score of a member in a sorted set",
    complexity: "O(log(N))",
  },
  {
    name: "ZINTERSTORE",
    args: "destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]",
    summary: "Intersect multiple sorted sets and store the resulting sorted set in a new key",
    complexity: "O(N*K)+O(M*log(M))",
  },
  {
    name: "ZLEXCOUNT",
    args: "key min max",
    summary: "Count the number of members in a sorted set between a given lexicographical range",
    complexity: "O(log(N))",
  },
  {
    name: "ZRANGE",
    args: "key start stop [WITHSCORES]",
    summary: "Return a range of members in a sorted set, by index",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZRANGEBYLEX",
    args: "key min max [LIMIT offset count]",
    summary: "Return a range of members in a sorted set, by lexicographical range",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZRANGEBYSCORE",
    args: "key min max [WITHSCORES] [LIMIT offset count]",
    summary: "Return a range of members in a sorted set, by score",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZRANK",
    args: "key member",
    summary: "Determine the index of a member in a sorted set",
    complexity: "O(log(N))",
  },
  {
    name: "ZREM",
    args: "key member [member ...]",
    summary: "Remove one or more members from a sorted set",
    complexity: "O(M*log(N))",
  },
  {
    name: "ZREMRANGEBYLEX",
    args: "key min max",
    summary: "Remove all members in a sorted set between the given lexicographical range",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREMRANGEBYRANK",
    args: "key start stop",
    summary: "Remove all members in a sorted set within the given indexes",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREMRANGEBYSCORE",
    args: "key min max",
    summary: "Remove all members in a sorted set within the given scores",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREVRANGE",
    args: "key start stop [WITHSCORES]",
    summary:
      "Return a range of members in a sorted set, by index, with scores ordered from high to low",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREVRANGEBYLEX",
    args: "key max min [LIMIT offset count]",
    summary:
      "Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREVRANGEBYSCORE",
    args: "key max min [WITHSCORES] [LIMIT offset count]",
    summary:
      "Return a range of members in a sorted set, by score, with scores ordered from high to low",
    complexity: "O(log(N)+M)",
  },
  {
    name: "ZREVRANK",
    args: "key member",
    summary:
      "Determine the index of a member in a sorted set, with scores ordered from high to low",
    complexity: "O(log(N))",
  },
  {
    name: "ZSCAN",
    args: "key cursor [MATCH pattern] [COUNT count]",
    summary: "Incrementally iterate sorted sets elements and associated scores",
    complexity: "O(1)",
  },
  {
    name: "ZSCORE",
    args: "key member",
    summary: "Get the score associated with the given member in a sorted set",
    complexity: "O(1)",
  },
  {
    name: "ZUNIONSTORE",
    args: "destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]",
    summary: "Add multiple sorted sets and store the resulting sorted set in a new key",
    complexity: "O(N)+O(M log(M))",
  },
  // RedisJSON commands
  { name: "JSON.DEL", args: "key [path]", summary: "Delete a value", complexity: "O(N)" },
  { name: "JSON.GET", args: "key [path]", summary: "Get a value", complexity: "O(N)" },
  {
    name: "JSON.MGET",
    args: "key [key ...] path",
    summary: "Get values from multiple keys",
    complexity: "O(M*N)",
  },
  { name: "JSON.SET", args: "key path value [NX|XX]", summary: "Set a value", complexity: "O(N)" },
  { name: "JSON.TYPE", args: "key [path]", summary: "Get the type of a value", complexity: "O(1)" },
  {
    name: "JSON.NUMINCRBY",
    args: "key path number",
    summary: "Increment a number",
    complexity: "O(1)",
  },
  {
    name: "JSON.NUMMULTBY",
    args: "key path number",
    summary: "Multiply a number",
    complexity: "O(1)",
  },
  {
    name: "JSON.STRAPPEND",
    args: "key [path] string",
    summary: "Append to a string",
    complexity: "O(N)",
  },
  { name: "JSON.STRLEN", args: "key [path]", summary: "Get string length", complexity: "O(1)" },
  {
    name: "JSON.ARRAPPEND",
    args: "key path value [value ...]",
    summary: "Append to array",
    complexity: "O(1)",
  },
  {
    name: "JSON.ARRINDEX",
    args: "key path value [start [stop]]",
    summary: "Find index in array",
    complexity: "O(N)",
  },
  {
    name: "JSON.ARRINSERT",
    args: "key path index value [value ...]",
    summary: "Insert into array",
    complexity: "O(N)",
  },
  { name: "JSON.ARRLEN", args: "key [path]", summary: "Get array length", complexity: "O(1)" },
  {
    name: "JSON.ARRPOP",
    args: "key [path] [index]",
    summary: "Pop from array",
    complexity: "O(1)",
  },
  { name: "JSON.ARRTRIM", args: "key path start stop", summary: "Trim array", complexity: "O(N)" },
  { name: "JSON.OBJKEYS", args: "key [path]", summary: "Get object keys", complexity: "O(N)" },
  { name: "JSON.OBJLEN", args: "key [path]", summary: "Get object length", complexity: "O(1)" },
  {
    name: "JSON.DEBUG",
    args: "subcommand key [path]",
    summary: "Debug command",
    complexity: "O(N)",
  },
  {
    name: "JSON.FORGET",
    args: "key [path]",
    summary: "Delete a value (alias for JSON.DEL)",
    complexity: "O(N)",
  },
  {
    name: "JSON.RESP",
    args: "key [path]",
    summary: "Return value in Redis serialization protocol format",
    complexity: "O(N)",
  },
];

// Create a map for quick lookup
export const REDIS_COMMAND_MAP = new Map(REDIS_COMMANDS.map((cmd) => [cmd.name, cmd]));

// Get command suggestions based on input
export function getCommandSuggestions(input: string): RedisCommand[] {
  const upperInput = input.toUpperCase().trim();
  if (!upperInput) return [];

  return REDIS_COMMANDS.filter((cmd) => cmd.name.startsWith(upperInput)).slice(0, 10);
}

// Check if a command is valid
export function isValidCommand(command: string): boolean {
  const upperCommand = command.toUpperCase().trim();
  return REDIS_COMMAND_MAP.has(upperCommand);
}

// Get command info
export function getCommandInfo(command: string): RedisCommand | undefined {
  const upperCommand = command.toUpperCase().trim();
  return REDIS_COMMAND_MAP.get(upperCommand);
}
